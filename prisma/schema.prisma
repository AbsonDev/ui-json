// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// Auth Models (NextAuth v5 compatible)
// ============================================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  password      String // hashed with bcrypt
  image         String?
  isAdmin       Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  accounts           Account[]
  sessions           Session[]
  apps               App[]                // Apps created by user
  databaseConnections DatabaseConnection[] // Database connections owned by user

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================
// UI-JSON App Models
// ============================================

model App {
  id          String   @id @default(cuid())
  name        String
  json        String   @db.Text // UI-JSON definition
  description String?
  isPublic    Boolean  @default(false)
  version     String   @default("1.0.0")

  // Database configuration
  useLocalStorage      Boolean            @default(true)
  databaseConnectionId String?
  databaseConnection   DatabaseConnection? @relation(fields: [databaseConnectionId], references: [id], onDelete: SetNull)

  // Database state for this app (usado quando useLocalStorage = true)
  databaseData Json?    // Stores the dynamic database content

  // Ownership
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Mobile builds
  builds      Build[]

  // Backend as a Service - Entities
  entities    Entity[]

  // App Users (authentication for end users)
  appUsers    AppUser[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([databaseConnectionId])
  @@map("apps")
}

// ============================================
// Database Connection Models
// ============================================

model DatabaseConnection {
  id          String   @id @default(cuid())
  name        String   // "Production DB", "Staging DB"

  // Connection details
  type        String   @default("postgresql") // postgresql, mysql, mongodb
  host        String
  port        Int      @default(5432)
  database    String
  username    String
  password    String   // encrypted with AES-256!
  ssl         Boolean  @default(false)

  // Status
  isActive    Boolean  @default(true)
  lastTestedAt DateTime?
  lastTestStatus String? // "success", "failed"
  lastTestError  String?

  // Ownership
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Apps using this connection
  apps        App[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([isActive])
  @@map("database_connections")
}

// ============================================
// Mobile Build Models
// ============================================

model Build {
  id            String   @id @default(cuid())

  // Build configuration
  platform      String   // "android" | "ios"
  buildType     String   // "debug" | "release"
  status        String   // "pending" | "building" | "success" | "failed"

  // App configuration for this build
  bundleId      String   // com.myapp.myproject
  appVersion    String   // 1.0.0
  versionCode   Int      // 1, 2, 3...
  appName       String   // Name of the app at build time

  // Build output
  downloadUrl   String?  // URL to download AAB/IPA
  fileSize      Int?     // File size in bytes
  fileName      String?  // app-release.aab

  // Error info (if failed)
  error         String?  @db.Text
  errorDetails  String?  @db.Text

  // Build metadata
  buildDuration Int?     // Duration in seconds
  completedAt   DateTime?

  // Relation to app
  appId         String
  app           App      @relation(fields: [appId], references: [id], onDelete: Cascade)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([appId])
  @@index([status])
  @@index([platform])
  @@map("builds")
}

// ============================================
// Backend as a Service (BaaS) Models
// ============================================

model Entity {
  id          String   @id @default(cuid())
  name        String   // "Product", "Category", "User", etc.
  displayName String?  // "Products", "Categories" (plural, user-friendly)
  description String?  // Description of what this entity represents

  // Schema definition (stored as JSON)
  fields      Json     // Array of field definitions: [{ name: "title", type: "string", required: true, ... }]

  // Options
  timestamps  Boolean  @default(true) // Auto-add createdAt/updatedAt fields
  softDelete  Boolean  @default(false) // Add deletedAt field for soft deletes

  // Permissions (access control for app users)
  // "public" = anyone can read (no auth required)
  // "authenticated" = only authenticated app users can read
  // "owner" = only data owner can read (requires appUserId)
  // "admin" = only app admin can read (via dashboard)
  readPermission  String @default("authenticated") // public | authenticated | owner | admin
  writePermission String @default("owner")          // authenticated | owner | admin
  deletePermission String @default("owner")         // owner | admin

  // Relation to app
  appId       String
  app         App      @relation(fields: [appId], references: [id], onDelete: Cascade)

  // Entity data records
  records     EntityData[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Ensure unique entity names per app
  @@unique([appId, name])
  @@index([appId])
  @@map("entities")
}

model EntityData {
  id          String   @id @default(cuid())

  // Data payload (stored as JSON)
  data        Json     // Actual data: { "title": "iPhone 15", "price": 999, ... }

  // Soft delete support
  deletedAt   DateTime?

  // User ownership (optional - for user-specific data)
  appUserId   String?
  appUser     AppUser? @relation(fields: [appUserId], references: [id], onDelete: Cascade)

  // Relation to entity
  entityId    String
  entity      Entity   @relation(fields: [entityId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([entityId])
  @@index([deletedAt])
  @@index([appUserId])
  @@map("entity_data")
}

// ============================================
// App User Authentication Models
// ============================================

model AppUser {
  id            String   @id @default(cuid())
  email         String
  passwordHash  String   // hashed with bcrypt
  name          String?
  avatar        String?
  emailVerified Boolean  @default(false)

  // App relation
  appId         String
  app           App      @relation(fields: [appId], references: [id], onDelete: Cascade)

  // Sessions for this user
  sessions      AppSession[]

  // Data owned by this user
  entityData    EntityData[]

  // Metadata
  metadata      Json?    // Custom user data (profile fields, preferences, etc.)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastLoginAt   DateTime?

  // Ensure unique email per app
  @@unique([appId, email])
  @@index([appId])
  @@index([email])
  @@map("app_users")
}

model AppSession {
  id           String   @id @default(cuid())
  token        String   @unique // JWT token
  expiresAt    DateTime

  // User relation
  appUserId    String
  appUser      AppUser  @relation(fields: [appUserId], references: [id], onDelete: Cascade)

  // Device/Client info
  userAgent    String?
  ipAddress    String?

  createdAt    DateTime @default(now())
  lastUsedAt   DateTime @default(now())

  @@index([appUserId])
  @@index([token])
  @@index([expiresAt])
  @@map("app_sessions")
}
